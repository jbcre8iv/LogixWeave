import {
  Document,
  Packer,
  Paragraph,
  TextRun,
  HeadingLevel,
  Table,
  TableRow,
  TableCell,
  WidthType,
  AlignmentType,
  BorderStyle,
  PageBreak,
  Footer,
  PageNumber,
  NumberFormat,
} from "docx";
import type {
  ManualDocument,
  CoverContent,
  TocContent,
  NarrativeContent,
  TasksContent,
  ProgramsContent,
  TagDatabaseContent,
  CrossReferenceContent,
  QualityMetricsContent,
} from "./types";

const FONT = "Calibri";
const TABLE_HEADER_COLOR = "3B82F6";
const TABLE_ALT_COLOR = "F5F7FA";

function heading(text: string, level: typeof HeadingLevel[keyof typeof HeadingLevel]): Paragraph {
  return new Paragraph({
    heading: level,
    spacing: { before: 240, after: 120 },
    children: [new TextRun({ text, font: FONT, bold: true })],
  });
}

function paragraph(text: string, options?: { bold?: boolean; italic?: boolean; spacing?: { before?: number; after?: number } }): Paragraph {
  return new Paragraph({
    spacing: options?.spacing || { after: 100 },
    children: [
      new TextRun({
        text,
        bold: options?.bold,
        italics: options?.italic,
        font: FONT,
        size: 22, // 11pt
      }),
    ],
  });
}

function makeTable(headers: string[], rows: string[][]): Table {
  const headerRow = new TableRow({
    tableHeader: true,
    children: headers.map(
      (h) =>
        new TableCell({
          shading: { fill: TABLE_HEADER_COLOR },
          children: [
            new Paragraph({
              children: [new TextRun({ text: h, bold: true, color: "FFFFFF", font: FONT, size: 20 })],
            }),
          ],
        })
    ),
  });

  const dataRows = rows.map(
    (row, i) =>
      new TableRow({
        children: row.map(
          (cell) =>
            new TableCell({
              shading: i % 2 === 1 ? { fill: TABLE_ALT_COLOR } : undefined,
              children: [
                new Paragraph({
                  children: [new TextRun({ text: cell, font: FONT, size: 20 })],
                }),
              ],
            })
        ),
      })
  );

  return new Table({
    width: { size: 100, type: WidthType.PERCENTAGE },
    borders: {
      top: { style: BorderStyle.SINGLE, size: 1, color: "D1D5DB" },
      bottom: { style: BorderStyle.SINGLE, size: 1, color: "D1D5DB" },
      left: { style: BorderStyle.SINGLE, size: 1, color: "D1D5DB" },
      right: { style: BorderStyle.SINGLE, size: 1, color: "D1D5DB" },
      insideHorizontal: { style: BorderStyle.SINGLE, size: 1, color: "D1D5DB" },
      insideVertical: { style: BorderStyle.SINGLE, size: 1, color: "D1D5DB" },
    },
    rows: [headerRow, ...dataRows],
  });
}

/**
 * Render a ManualDocument to DOCX Blob.
 */
export async function renderDocx(document: ManualDocument): Promise<Blob> {
  const children: (Paragraph | Table)[] = [];

  for (const section of document.sections) {
    const content = section.content;

    switch (content.type) {
      case "cover": {
        const c = content as CoverContent;
        const date = new Date(c.generatedDate).toLocaleDateString();

        // Spacer
        children.push(new Paragraph({ spacing: { before: 2400 } }));

        children.push(
          new Paragraph({
            alignment: AlignmentType.CENTER,
            spacing: { after: 200 },
            children: [new TextRun({ text: c.projectName, bold: true, font: FONT, size: 56 })],
          })
        );
        children.push(
          new Paragraph({
            alignment: AlignmentType.CENTER,
            spacing: { after: 400 },
            children: [new TextRun({ text: "Project Manual", font: FONT, size: 32 })],
          })
        );

        if (c.processorType) {
          children.push(
            new Paragraph({
              alignment: AlignmentType.CENTER,
              children: [new TextRun({ text: `Processor: ${c.processorType}`, font: FONT, size: 24 })],
            })
          );
        }
        if (c.softwareRevision) {
          children.push(
            new Paragraph({
              alignment: AlignmentType.CENTER,
              children: [new TextRun({ text: `Software Revision: ${c.softwareRevision}`, font: FONT, size: 24 })],
            })
          );
        }
        children.push(
          new Paragraph({
            alignment: AlignmentType.CENTER,
            spacing: { after: 200 },
            children: [new TextRun({ text: `Generated: ${date}`, font: FONT, size: 24 })],
          })
        );
        children.push(
          new Paragraph({
            alignment: AlignmentType.CENTER,
            children: [
              new TextRun({ text: "Generated by LogixWeave", italics: true, color: "999999", font: FONT, size: 20 }),
            ],
          })
        );
        children.push(new Paragraph({ children: [new PageBreak()] }));
        break;
      }

      case "toc": {
        const c = content as TocContent;
        children.push(heading("Table of Contents", HeadingLevel.HEADING_1));
        for (let i = 0; i < c.entries.length; i++) {
          children.push(paragraph(`${i + 1}. ${c.entries[i].title}`));
        }
        children.push(new Paragraph({ children: [new PageBreak()] }));
        break;
      }

      case "narrative": {
        const c = content as NarrativeContent;
        children.push(heading(section.title, HeadingLevel.HEADING_1));
        if (c.narrative) children.push(paragraph(c.narrative));
        const labels: Record<string, string> = {
          programs: "Programs", routines: "Routines", tags: "Tags",
          ioModules: "I/O Modules", udts: "User-Defined Types", aois: "Add-On Instructions",
          tasks: "Tasks", rungs: "Rungs", taskTypes: "Task Types",
        };
        children.push(
          makeTable(
            ["Metric", "Count"],
            Object.entries(c.stats).map(([key, value]) => [labels[key] || key, value.toString()])
          )
        );
        break;
      }

      case "tasks": {
        const c = content as TasksContent;
        children.push(heading("System Architecture", HeadingLevel.HEADING_1));
        if (c.narrative) children.push(paragraph(c.narrative));
        if (c.tasks.length > 0) {
          children.push(heading("Task Configuration", HeadingLevel.HEADING_2));
          children.push(
            makeTable(
              ["Task Name", "Type", "Rate (ms)", "Priority", "Watchdog (ms)"],
              c.tasks.map((t) => [t.name, t.type, t.rate?.toString() ?? "-", t.priority.toString(), t.watchdog?.toString() ?? "-"])
            )
          );
          children.push(heading("Program Execution Order", HeadingLevel.HEADING_2));
          for (const task of c.tasks) {
            if (task.scheduledPrograms.length > 0) {
              children.push(paragraph(`${task.name} (${task.type}): ${task.scheduledPrograms.join(" \u2192 ")}`));
            }
          }
        } else {
          children.push(paragraph("No tasks defined in this project.", { italic: true }));
        }
        break;
      }

      case "io":
        children.push(heading("I/O Configuration", HeadingLevel.HEADING_1));
        if (content.modules.length > 0) {
          children.push(
            makeTable(
              ["Module Name", "Catalog Number", "Parent Module", "Slot"],
              content.modules.map((m) => [m.name, m.catalogNumber || "-", m.parentModule || "-", m.slot?.toString() ?? "-"])
            )
          );
        } else {
          children.push(paragraph("No I/O modules found in this project.", { italic: true }));
        }
        break;

      case "programs": {
        const c = content as ProgramsContent;
        children.push(heading("Programs & Routines", HeadingLevel.HEADING_1));
        for (const program of c.programs) {
          children.push(heading(program.name, HeadingLevel.HEADING_2));
          if (program.narrative) children.push(paragraph(program.narrative));
          children.push(
            makeTable(
              ["Routine", "Type", "Rungs", "Description"],
              program.routines.map((r) => [r.name, r.type, r.rungCount?.toString() ?? "-", r.description || r.summary || "-"])
            )
          );
          const summarized = program.routines.filter((r) => r.summary);
          if (summarized.length > 0) {
            children.push(heading("Routine Summaries", HeadingLevel.HEADING_3));
            for (const r of summarized) {
              children.push(
                new Paragraph({
                  spacing: { after: 80 },
                  children: [
                    new TextRun({ text: `${r.name}: `, bold: true, font: FONT, size: 22 }),
                    new TextRun({ text: r.summary!, font: FONT, size: 22 }),
                  ],
                })
              );
            }
          }
        }
        break;
      }

      case "tagDatabase": {
        const c = content as TagDatabaseContent;
        children.push(heading("Tag Database", HeadingLevel.HEADING_1));
        if (c.controllerTags.length > 0) {
          children.push(heading("Controller-Scoped Tags", HeadingLevel.HEADING_2));
          children.push(
            makeTable(
              ["Name", "Data Type", "Description", "Usage", "Radix"],
              c.controllerTags.map((t) => [t.name, t.dataType, t.description || "-", t.usage || "-", t.radix || "-"])
            )
          );
        }
        for (const group of c.programTags) {
          children.push(heading(`${group.programName} Tags`, HeadingLevel.HEADING_2));
          children.push(
            makeTable(
              ["Name", "Data Type", "Description", "Usage", "Radix"],
              group.tags.map((t) => [t.name, t.dataType, t.description || "-", t.usage || "-", t.radix || "-"])
            )
          );
        }
        if (c.aliasTags.length > 0) {
          children.push(heading("Alias Tags", HeadingLevel.HEADING_2));
          children.push(
            makeTable(
              ["Alias Name", "Points To", "Data Type", "Description"],
              c.aliasTags.map((t) => [t.name, t.aliasFor, t.dataType, t.description || "-"])
            )
          );
        }
        break;
      }

      case "udts":
        children.push(heading("User-Defined Types", HeadingLevel.HEADING_1));
        if (content.udts.length > 0) {
          for (const udt of content.udts) {
            children.push(heading(udt.name, HeadingLevel.HEADING_2));
            if (udt.description) children.push(paragraph(udt.description, { italic: true }));
            if (udt.familyType) children.push(paragraph(`Family: ${udt.familyType}`, { bold: true }));
            if (udt.members.length > 0) {
              children.push(
                makeTable(
                  ["Member", "Data Type", "Description"],
                  udt.members.map((m) => [m.name, m.dataType, m.description || "-"])
                )
              );
            }
          }
        } else {
          children.push(paragraph("No user-defined types found in this project.", { italic: true }));
        }
        break;

      case "aois":
        children.push(heading("Add-On Instructions", HeadingLevel.HEADING_1));
        if (content.aois.length > 0) {
          for (const aoi of content.aois) {
            children.push(heading(aoi.name, HeadingLevel.HEADING_2));
            if (aoi.description) children.push(paragraph(aoi.description, { italic: true }));
            if (aoi.revision) children.push(paragraph(`Revision: ${aoi.revision}`));
            if (aoi.vendor) children.push(paragraph(`Vendor: ${aoi.vendor}`));
            if (aoi.parameters.length > 0) {
              children.push(heading("Parameters", HeadingLevel.HEADING_3));
              children.push(
                makeTable(
                  ["Parameter", "Data Type", "Usage", "Description"],
                  aoi.parameters.map((p) => [p.name, p.dataType, p.usage, p.description || "-"])
                )
              );
            }
            if (aoi.localTags.length > 0) {
              children.push(heading("Local Tags", HeadingLevel.HEADING_3));
              children.push(
                makeTable(
                  ["Name", "Data Type", "Description"],
                  aoi.localTags.map((t) => [t.name, t.dataType, t.description || "-"])
                )
              );
            }
          }
        } else {
          children.push(paragraph("No add-on instructions found in this project.", { italic: true }));
        }
        break;

      case "crossReference": {
        const c = content as CrossReferenceContent;
        children.push(heading("Cross-Reference Summary", HeadingLevel.HEADING_1));
        if (c.topTags.length > 0) {
          children.push(heading("Most Referenced Tags", HeadingLevel.HEADING_2));
          children.push(
            makeTable(
              ["Tag Name", "Total Refs", "Read", "Write", "R/W", "Programs"],
              c.topTags.map((t) => [t.name, t.totalReferences.toString(), t.readCount.toString(), t.writeCount.toString(), t.bothCount.toString(), t.programsUsedIn.join(", ")])
            )
          );
        }
        if (c.multiProgramTags.length > 0) {
          children.push(heading("Tags Across Multiple Programs", HeadingLevel.HEADING_2));
          children.push(
            makeTable(
              ["Tag Name", "Programs"],
              c.multiProgramTags.slice(0, 30).map((t) => [t.name, t.programs.join(", ")])
            )
          );
        }
        break;
      }

      case "qualityMetrics": {
        const c = content as QualityMetricsContent;
        children.push(heading("Quality Metrics", HeadingLevel.HEADING_1));
        children.push(
          makeTable(
            ["Metric", "Value"],
            [
              ["Unused Tags", c.unusedTagCount.toString()],
              ["Overall Comment Coverage", `${c.overallCommentCoverage}%`],
            ]
          )
        );
        if (c.commentCoverage.length > 0) {
          children.push(heading("Comment Coverage by Routine", HeadingLevel.HEADING_2));
          children.push(
            makeTable(
              ["Program", "Routine", "Commented", "Total", "Coverage"],
              c.commentCoverage.map((e) => [e.programName, e.routineName, e.commented.toString(), e.total.toString(), `${e.coverage}%`])
            )
          );
        }
        if (c.unusedTags.length > 0) {
          children.push(heading("Unused Tags", HeadingLevel.HEADING_2));
          children.push(
            makeTable(
              ["Name", "Data Type", "Scope"],
              c.unusedTags.map((t) => [t.name, t.dataType, t.scope])
            )
          );
        }
        break;
      }
    }
  }

  const doc = new Document({
    sections: [
      {
        properties: {
          page: {
            margin: { top: 1440, bottom: 1440, left: 1440, right: 1440 },
          },
        },
        footers: {
          default: new Footer({
            children: [
              new Paragraph({
                alignment: AlignmentType.CENTER,
                children: [
                  new TextRun({
                    children: ["Page ", PageNumber.CURRENT, " of ", PageNumber.TOTAL_PAGES],
                    font: FONT,
                    size: 18,
                    color: "999999",
                  }),
                ],
              }),
              new Paragraph({
                alignment: AlignmentType.CENTER,
                children: [
                  new TextRun({
                    text: "Generated by LogixWeave",
                    font: FONT,
                    size: 16,
                    italics: true,
                    color: "BBBBBB",
                  }),
                ],
              }),
            ],
          }),
        },
        children,
      },
    ],
  });

  return await Packer.toBlob(doc);
}
