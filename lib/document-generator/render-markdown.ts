import type {
  ManualDocument,
  ManualSection,
  CoverContent,
  TocContent,
  NarrativeContent,
  TasksContent,
  IoContent,
  ProgramsContent,
  TagDatabaseContent,
  UdtContent,
  AoiContent,
  CrossReferenceContent,
  ProjectHealthContent,
} from "./types";

/**
 * Render a ManualDocument to Markdown string.
 */
export function renderMarkdown(doc: ManualDocument): string {
  const lines: string[] = [];

  for (const section of doc.sections) {
    renderSection(section, lines);
    lines.push("");
  }

  lines.push("---");
  lines.push("");
  lines.push("*Documentation generated by [LogixWeave](https://logixweave.com)*");

  return lines.join("\n");
}

function renderSection(section: ManualSection, lines: string[]) {
  const content = section.content;

  switch (content.type) {
    case "cover":
      renderCover(content, lines);
      break;
    case "toc":
      renderToc(content, lines);
      break;
    case "narrative":
      renderNarrative(section.title, content, lines);
      break;
    case "tasks":
      renderTasks(content, lines);
      break;
    case "io":
      renderIo(content, lines);
      break;
    case "programs":
      renderPrograms(content, lines);
      break;
    case "tagDatabase":
      renderTagDatabase(content, lines);
      break;
    case "udts":
      renderUdts(content, lines);
      break;
    case "aois":
      renderAois(content, lines);
      break;
    case "crossReference":
      renderCrossReference(content, lines);
      break;
    case "projectHealth":
      renderProjectHealth(content, lines);
      break;
  }
}

function renderCover(content: CoverContent, lines: string[]) {
  lines.push(`# ${content.projectName} â€” Project Manual`);
  lines.push("");
  const date = new Date(content.generatedDate).toLocaleDateString();
  lines.push(`*Generated by LogixWeave on ${date}*`);
  lines.push("");

  lines.push("## Project Information");
  lines.push("");
  lines.push("| Property | Value |");
  lines.push("|----------|-------|");
  if (content.processorType) lines.push(`| Processor Type | ${content.processorType} |`);
  if (content.softwareRevision) lines.push(`| Software Revision | ${content.softwareRevision} |`);
  if (content.exportDate) lines.push(`| Export Date | ${content.exportDate} |`);
  lines.push(`| Document Generated | ${date} |`);
  lines.push("");
}

function renderToc(content: TocContent, lines: string[]) {
  lines.push("## Table of Contents");
  lines.push("");
  for (const entry of content.entries) {
    const anchor = entry.title.toLowerCase().replace(/[^a-z0-9\s-]/g, "").replace(/\s+/g, "-");
    lines.push(`- [${entry.title}](#${anchor})`);
  }
  lines.push("");
}

function renderNarrative(title: string, content: NarrativeContent, lines: string[]) {
  lines.push(`## ${title}`);
  lines.push("");

  if (content.narrative) {
    lines.push(content.narrative);
    lines.push("");
  }

  // Stats table
  lines.push("| Metric | Count |");
  lines.push("|--------|-------|");
  const labels: Record<string, string> = {
    programs: "Programs",
    routines: "Routines",
    tags: "Tags",
    ioModules: "I/O Modules",
    udts: "User-Defined Types",
    aois: "Add-On Instructions",
    tasks: "Tasks",
    rungs: "Rungs",
    taskTypes: "Task Types",
  };
  for (const [key, value] of Object.entries(content.stats)) {
    lines.push(`| ${labels[key] || key} | ${value} |`);
  }
  lines.push("");
}

function renderTasks(content: TasksContent, lines: string[]) {
  lines.push("## System Architecture");
  lines.push("");

  if (content.narrative) {
    lines.push(content.narrative);
    lines.push("");
  }

  if (content.tasks.length === 0) {
    lines.push("*No tasks defined in this project.*");
    lines.push("");
    return;
  }

  // Task configuration table
  lines.push("### Task Configuration");
  lines.push("");
  lines.push("| Task Name | Type | Rate (ms) | Priority | Watchdog (ms) |");
  lines.push("|-----------|------|-----------|----------|---------------|");
  for (const task of content.tasks) {
    lines.push(`| ${task.name} | ${task.type} | ${task.rate ?? "-"} | ${task.priority} | ${task.watchdog ?? "-"} |`);
  }
  lines.push("");

  // Program execution order per task
  lines.push("### Program Execution Order");
  lines.push("");
  for (const task of content.tasks) {
    if (task.scheduledPrograms.length > 0) {
      lines.push(`**${task.name}** (${task.type}):`);
      for (let i = 0; i < task.scheduledPrograms.length; i++) {
        lines.push(`${i + 1}. ${task.scheduledPrograms[i]}`);
      }
      lines.push("");
    }
  }
}

function renderIo(content: IoContent, lines: string[]) {
  lines.push("## I/O Configuration");
  lines.push("");

  if (content.modules.length === 0) {
    lines.push("*No I/O modules found in this project.*");
    lines.push("");
    return;
  }

  lines.push("| Module Name | Catalog Number | Parent Module | Slot |");
  lines.push("|-------------|----------------|---------------|------|");
  for (const mod of content.modules) {
    lines.push(`| ${mod.name} | ${mod.catalogNumber || "-"} | ${mod.parentModule || "-"} | ${mod.slot ?? "-"} |`);
  }
  lines.push("");
}

function renderPrograms(content: ProgramsContent, lines: string[]) {
  lines.push("## Programs & Routines");
  lines.push("");

  for (const program of content.programs) {
    lines.push(`### ${program.name}`);
    lines.push("");

    if (program.narrative) {
      lines.push(program.narrative);
      lines.push("");
    }

    lines.push("| Routine | Type | Rungs | Description |");
    lines.push("|---------|------|-------|-------------|");
    for (const routine of program.routines) {
      const desc = routine.description || routine.summary || "-";
      lines.push(`| ${routine.name} | ${routine.type} | ${routine.rungCount ?? "-"} | ${desc} |`);
    }
    lines.push("");

    // Render routine summaries if present
    const summarized = program.routines.filter((r) => r.summary);
    if (summarized.length > 0) {
      lines.push("#### Routine Summaries");
      lines.push("");
      for (const routine of summarized) {
        lines.push(`**${routine.name}:** ${routine.summary}`);
        lines.push("");
      }
    }
  }
}

function renderTagDatabase(content: TagDatabaseContent, lines: string[]) {
  lines.push("## Tag Database");
  lines.push("");

  // Controller-scoped tags
  if (content.controllerTags.length > 0) {
    lines.push("### Controller-Scoped Tags");
    lines.push("");
    lines.push("| Name | Data Type | Description | Usage | Radix |");
    lines.push("|------|-----------|-------------|-------|-------|");
    for (const tag of content.controllerTags) {
      lines.push(`| \`${tag.name}\` | ${tag.dataType} | ${tag.description || "-"} | ${tag.usage || "-"} | ${tag.radix || "-"} |`);
    }
    lines.push("");
  }

  // Program-scoped tags
  for (const group of content.programTags) {
    lines.push(`### ${group.programName} Tags`);
    lines.push("");
    lines.push("| Name | Data Type | Description | Usage | Radix |");
    lines.push("|------|-----------|-------------|-------|-------|");
    for (const tag of group.tags) {
      lines.push(`| \`${tag.name}\` | ${tag.dataType} | ${tag.description || "-"} | ${tag.usage || "-"} | ${tag.radix || "-"} |`);
    }
    lines.push("");
  }

  // Alias tags
  if (content.aliasTags.length > 0) {
    lines.push("### Alias Tags");
    lines.push("");
    lines.push("| Alias Name | Points To | Data Type | Description |");
    lines.push("|------------|-----------|-----------|-------------|");
    for (const tag of content.aliasTags) {
      lines.push(`| \`${tag.name}\` | \`${tag.aliasFor}\` | ${tag.dataType} | ${tag.description || "-"} |`);
    }
    lines.push("");
  }
}

function renderUdts(content: UdtContent, lines: string[]) {
  lines.push("## User-Defined Types");
  lines.push("");

  if (content.udts.length === 0) {
    lines.push("*No user-defined types found in this project.*");
    lines.push("");
    return;
  }

  for (const udt of content.udts) {
    lines.push(`### ${udt.name}`);
    lines.push("");
    if (udt.description) lines.push(`*${udt.description}*`);
    if (udt.familyType) lines.push(`**Family:** ${udt.familyType}`);
    lines.push("");

    if (udt.members.length > 0) {
      lines.push("| Member | Data Type | Description |");
      lines.push("|--------|-----------|-------------|");
      for (const member of udt.members) {
        lines.push(`| ${member.name} | ${member.dataType} | ${member.description || "-"} |`);
      }
      lines.push("");
    }
  }
}

function renderAois(content: AoiContent, lines: string[]) {
  lines.push("## Add-On Instructions");
  lines.push("");

  if (content.aois.length === 0) {
    lines.push("*No add-on instructions found in this project.*");
    lines.push("");
    return;
  }

  for (const aoi of content.aois) {
    lines.push(`### ${aoi.name}`);
    lines.push("");
    if (aoi.description) lines.push(`*${aoi.description}*`);
    lines.push("");
    if (aoi.revision) lines.push(`**Revision:** ${aoi.revision}`);
    if (aoi.vendor) lines.push(`**Vendor:** ${aoi.vendor}`);
    lines.push("");

    if (aoi.parameters.length > 0) {
      lines.push("#### Parameters");
      lines.push("");
      lines.push("| Parameter | Data Type | Usage | Description |");
      lines.push("|-----------|-----------|-------|-------------|");
      for (const param of aoi.parameters) {
        lines.push(`| ${param.name} | ${param.dataType} | ${param.usage} | ${param.description || "-"} |`);
      }
      lines.push("");
    }

    if (aoi.localTags.length > 0) {
      lines.push("#### Local Tags");
      lines.push("");
      lines.push("| Name | Data Type | Description |");
      lines.push("|------|-----------|-------------|");
      for (const tag of aoi.localTags) {
        lines.push(`| ${tag.name} | ${tag.dataType} | ${tag.description || "-"} |`);
      }
      lines.push("");
    }
  }
}

function renderCrossReference(content: CrossReferenceContent, lines: string[]) {
  lines.push("## Cross-Reference Summary");
  lines.push("");

  // Top referenced tags
  if (content.topTags.length > 0) {
    lines.push("### Most Referenced Tags");
    lines.push("");
    lines.push("| Tag Name | Total Refs | Read | Write | Read/Write | Programs |");
    lines.push("|----------|-----------|------|-------|------------|----------|");
    for (const tag of content.topTags) {
      lines.push(`| \`${tag.name}\` | ${tag.totalReferences} | ${tag.readCount} | ${tag.writeCount} | ${tag.bothCount} | ${tag.programsUsedIn.join(", ")} |`);
    }
    lines.push("");
  }

  // Multi-program tags
  if (content.multiProgramTags.length > 0) {
    lines.push("### Tags Used Across Multiple Programs");
    lines.push("");
    lines.push("| Tag Name | Programs |");
    lines.push("|----------|----------|");
    for (const tag of content.multiProgramTags.slice(0, 30)) {
      lines.push(`| \`${tag.name}\` | ${tag.programs.join(", ")} |`);
    }
    lines.push("");
  }
}

function renderProjectHealth(content: ProjectHealthContent, lines: string[]) {
  lines.push("## Project Health");
  lines.push("");

  // Health score breakdown
  const hs = content.healthScore;
  lines.push("### Health Score");
  lines.push("");
  lines.push(`**Overall: ${hs.overall}/100**`);
  lines.push("");
  lines.push("| Metric | Score |");
  lines.push("|--------|-------|");
  lines.push(`| Tag Efficiency | ${hs.tagEfficiency}/100 |`);
  lines.push(`| Documentation | ${hs.documentation}/100 |`);
  lines.push(`| Tag Usage | ${hs.tagUsage}/100 |`);
  if (hs.taskConfig !== undefined) {
    lines.push(`| Task Configuration | ${hs.taskConfig}/100 |`);
  }
  lines.push("");

  // Findings
  if (content.findings.length > 0) {
    lines.push("### Findings");
    lines.push("");
    const severityIcon: Record<string, string> = { error: "CRITICAL", warning: "WARNING", info: "OK" };
    for (const finding of content.findings) {
      lines.push(`**[${severityIcon[finding.severity]}] ${finding.category}: ${finding.title}**`);
      lines.push("");
      lines.push(finding.description);
      if (finding.items && finding.items.length > 0) {
        lines.push("");
        for (const item of finding.items) {
          lines.push(`- ${item}`);
        }
      }
      lines.push("");
    }
  }

  // Comment coverage by routine
  if (content.commentCoverage.length > 0) {
    lines.push("### Comment Coverage by Routine");
    lines.push("");
    lines.push("| Program | Routine | Commented | Total | Coverage |");
    lines.push("|---------|---------|-----------|-------|----------|");
    for (const entry of content.commentCoverage) {
      lines.push(`| ${entry.programName} | ${entry.routineName} | ${entry.commented} | ${entry.total} | ${entry.coverage}% |`);
    }
    lines.push("");
  }

  // Unused tags list
  if (content.unusedTags.length > 0) {
    lines.push("### Unused Tags");
    lines.push("");
    lines.push("| Name | Data Type | Scope |");
    lines.push("|------|-----------|-------|");
    for (const tag of content.unusedTags) {
      lines.push(`| \`${tag.name}\` | ${tag.dataType} | ${tag.scope} |`);
    }
    lines.push("");
  }
}
