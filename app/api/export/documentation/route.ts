import { NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";
import { logActivity } from "@/lib/activity-log";

interface DocumentationSection {
  tags?: boolean;
  routines?: boolean;
  ioModules?: boolean;
  udts?: boolean;
  aois?: boolean;
}

interface Tag {
  name: string;
  data_type: string;
  scope: string;
  description: string | null;
}

interface Routine {
  name: string;
  program_name: string;
  type: string;
  description: string | null;
  rung_count: number | null;
}

interface IOModule {
  name: string;
  catalog_number: string | null;
  parent_module: string | null;
  slot: number | null;
}

interface UDT {
  name: string;
  description: string | null;
  family_type: string | null;
  parsed_udt_members: Array<{
    name: string;
    data_type: string;
    description: string | null;
  }>;
}

interface AOI {
  name: string;
  description: string | null;
  revision: string | null;
  vendor: string | null;
  parsed_aoi_parameters: Array<{
    name: string;
    data_type: string;
    usage: string;
    description: string | null;
  }>;
}

function generateMarkdown(
  projectName: string,
  data: {
    tags?: Tag[];
    routines?: Routine[];
    ioModules?: IOModule[];
    udts?: UDT[];
    aois?: AOI[];
  },
  metadata?: {
    processorType?: string;
    softwareRevision?: string;
    exportDate?: string;
  }
): string {
  const lines: string[] = [];
  const date = new Date().toLocaleDateString();

  lines.push(`# ${projectName} - PLC Documentation`);
  lines.push("");
  lines.push(`*Generated by LogixWeave on ${date}*`);
  lines.push("");

  if (metadata) {
    lines.push("## Project Information");
    lines.push("");
    lines.push("| Property | Value |");
    lines.push("|----------|-------|");
    if (metadata.processorType) lines.push(`| Processor Type | ${metadata.processorType} |`);
    if (metadata.softwareRevision) lines.push(`| Software Revision | ${metadata.softwareRevision} |`);
    if (metadata.exportDate) lines.push(`| Export Date | ${metadata.exportDate} |`);
    lines.push("");
  }

  // Table of Contents
  lines.push("## Table of Contents");
  lines.push("");
  if (data.tags && data.tags.length > 0) lines.push(`- [Tags](#tags) (${data.tags.length})`);
  if (data.routines && data.routines.length > 0) lines.push(`- [Routines](#routines) (${data.routines.length})`);
  if (data.ioModules && data.ioModules.length > 0) lines.push(`- [I/O Modules](#io-modules) (${data.ioModules.length})`);
  if (data.udts && data.udts.length > 0) lines.push(`- [User Defined Types](#user-defined-types) (${data.udts.length})`);
  if (data.aois && data.aois.length > 0) lines.push(`- [Add-On Instructions](#add-on-instructions) (${data.aois.length})`);
  lines.push("");

  // Tags Section
  if (data.tags && data.tags.length > 0) {
    lines.push("## Tags");
    lines.push("");
    lines.push("| Name | Data Type | Scope | Description |");
    lines.push("|------|-----------|-------|-------------|");
    for (const tag of data.tags) {
      lines.push(`| \`${tag.name}\` | ${tag.data_type} | ${tag.scope} | ${tag.description || "-"} |`);
    }
    lines.push("");
  }

  // Routines Section
  if (data.routines && data.routines.length > 0) {
    lines.push("## Routines");
    lines.push("");

    // Group by program
    const byProgram = new Map<string, Routine[]>();
    for (const routine of data.routines) {
      const existing = byProgram.get(routine.program_name) || [];
      existing.push(routine);
      byProgram.set(routine.program_name, existing);
    }

    for (const [programName, routines] of byProgram) {
      lines.push(`### ${programName}`);
      lines.push("");
      lines.push("| Routine | Type | Rungs | Description |");
      lines.push("|---------|------|-------|-------------|");
      for (const routine of routines) {
        lines.push(`| ${routine.name} | ${routine.type} | ${routine.rung_count ?? "-"} | ${routine.description || "-"} |`);
      }
      lines.push("");
    }
  }

  // I/O Modules Section
  if (data.ioModules && data.ioModules.length > 0) {
    lines.push("## I/O Modules");
    lines.push("");
    lines.push("| Name | Catalog Number | Parent Module | Slot |");
    lines.push("|------|----------------|---------------|------|");
    for (const module of data.ioModules) {
      lines.push(`| ${module.name} | ${module.catalog_number || "-"} | ${module.parent_module || "-"} | ${module.slot ?? "-"} |`);
    }
    lines.push("");
  }

  // UDTs Section
  if (data.udts && data.udts.length > 0) {
    lines.push("## User Defined Types");
    lines.push("");
    for (const udt of data.udts) {
      lines.push(`### ${udt.name}`);
      lines.push("");
      if (udt.description) lines.push(`*${udt.description}*`);
      if (udt.family_type) lines.push(`**Family:** ${udt.family_type}`);
      lines.push("");
      if (udt.parsed_udt_members && udt.parsed_udt_members.length > 0) {
        lines.push("| Member | Data Type | Description |");
        lines.push("|--------|-----------|-------------|");
        for (const member of udt.parsed_udt_members) {
          lines.push(`| ${member.name} | ${member.data_type} | ${member.description || "-"} |`);
        }
      }
      lines.push("");
    }
  }

  // AOIs Section
  if (data.aois && data.aois.length > 0) {
    lines.push("## Add-On Instructions");
    lines.push("");
    for (const aoi of data.aois) {
      lines.push(`### ${aoi.name}`);
      lines.push("");
      if (aoi.description) lines.push(`*${aoi.description}*`);
      lines.push("");
      if (aoi.revision) lines.push(`**Revision:** ${aoi.revision}`);
      if (aoi.vendor) lines.push(`**Vendor:** ${aoi.vendor}`);
      lines.push("");
      if (aoi.parsed_aoi_parameters && aoi.parsed_aoi_parameters.length > 0) {
        lines.push("#### Parameters");
        lines.push("");
        lines.push("| Parameter | Data Type | Usage | Description |");
        lines.push("|-----------|-----------|-------|-------------|");
        for (const param of aoi.parsed_aoi_parameters) {
          lines.push(`| ${param.name} | ${param.data_type} | ${param.usage} | ${param.description || "-"} |`);
        }
      }
      lines.push("");
    }
  }

  lines.push("---");
  lines.push("");
  lines.push("*Documentation generated by [LogixWeave](https://logixweave.com)*");

  return lines.join("\n");
}

export async function POST(request: Request) {
  try {
    const supabase = await createClient();

    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { projectId, sections, format } = await request.json();

    if (!projectId) {
      return NextResponse.json({ error: "projectId is required" }, { status: 400 });
    }

    const sectionConfig: DocumentationSection = sections || {
      tags: true,
      routines: true,
      ioModules: true,
      udts: true,
      aois: true,
    };

    // Get project info
    const { data: project } = await supabase
      .from("projects")
      .select("id, name, project_files(id, parsing_status)")
      .eq("id", projectId)
      .single();

    if (!project) {
      return NextResponse.json({ error: "Project not found" }, { status: 404 });
    }

    const fileIds = project.project_files
      ?.filter((f: { parsing_status: string }) => f.parsing_status === "completed")
      .map((f: { id: string }) => f.id) || [];

    if (fileIds.length === 0) {
      return NextResponse.json({ error: "No parsed files in project" }, { status: 400 });
    }

    const data: {
      tags?: Tag[];
      routines?: Routine[];
      ioModules?: IOModule[];
      udts?: UDT[];
      aois?: AOI[];
    } = {};

    // Fetch requested sections
    const queries = [];

    if (sectionConfig.tags) {
      queries.push(
        supabase
          .from("parsed_tags")
          .select("name, data_type, scope, description")
          .in("file_id", fileIds)
          .order("scope")
          .order("name")
          .then((res) => {
            data.tags = res.data || [];
          })
      );
    }

    if (sectionConfig.routines) {
      queries.push(
        supabase
          .from("parsed_routines")
          .select("name, program_name, type, description, rung_count")
          .in("file_id", fileIds)
          .order("program_name")
          .order("name")
          .then((res) => {
            data.routines = res.data || [];
          })
      );
    }

    if (sectionConfig.ioModules) {
      queries.push(
        supabase
          .from("parsed_io_modules")
          .select("name, catalog_number, parent_module, slot")
          .in("file_id", fileIds)
          .order("slot")
          .then((res) => {
            data.ioModules = res.data || [];
          })
      );
    }

    if (sectionConfig.udts) {
      queries.push(
        supabase
          .from("parsed_udts")
          .select("name, description, family_type, parsed_udt_members(name, data_type, description)")
          .in("file_id", fileIds)
          .order("name")
          .then((res) => {
            data.udts = res.data || [];
          })
      );
    }

    if (sectionConfig.aois) {
      queries.push(
        supabase
          .from("parsed_aois")
          .select("name, description, revision, vendor, parsed_aoi_parameters(name, data_type, usage, description)")
          .in("file_id", fileIds)
          .order("name")
          .then((res) => {
            data.aois = res.data || [];
          })
      );
    }

    await Promise.all(queries);

    // Generate documentation
    const markdown = generateMarkdown(project.name, data);

    const date = new Date().toISOString().split("T")[0];
    const filename = `${project.name.replace(/[^a-zA-Z0-9]/g, "_")}_Documentation_${date}.md`;

    await logActivity({
      projectId,
      userId: user.id,
      userEmail: user.email,
      action: "documentation_exported",
      targetType: "export",
      targetName: "markdown",
    });

    return new NextResponse(markdown, {
      headers: {
        "Content-Type": "text/markdown",
        "Content-Disposition": `attachment; filename="${filename}"`,
      },
    });
  } catch (error) {
    console.error("Documentation export error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
